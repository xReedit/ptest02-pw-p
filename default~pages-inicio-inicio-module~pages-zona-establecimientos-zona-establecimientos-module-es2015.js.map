{"version":3,"sources":["./node_modules/ngx-quicklink/__ivy_ngcc__/fesm2015/ngx-quicklink.js","./src/app/shared/shared.module.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwD;AAC6D;AACX;AAC7E;;AAE7B;AACA;AACwC;AACE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,oCAAoC,sDAAe,CAAC,sDAAa,GAAG;AAClI,yBAAyB,gEAAyB,EAAE,iDAAiD,iCAAiC,EAAE,EAAE;AAC1I,mBAAmB,wDAAU,GAAG,wDAAU,uBAAuB,sDAAM;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAc;AAC9C;AACA,uDAAuD,8DAAc;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC,cAAc;AACf;AACA;AACA;AACA;AACA,wBAAwB,4DAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,yCAAyC,sDAAe,CAAC,+DAAsB,GAAG,sDAAe,oBAAoB;AAC7L,8BAA8B,gEAAyB,EAAE,sDAAsD,sCAAsC,EAAE,EAAE;AACzJ,wBAAwB,wDAAU,GAAG,wDAAU,uBAAuB,+DAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,kEAAkE,sCAAsC,sDAAe,CAAC,+DAAsB,GAAG,sDAAe,o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","file":"default~pages-inicio-inicio-module~pages-zona-establecimientos-zona-establecimientos-module-es2015.js","sourcesContent":["import { __decorate, __metadata, __param } from 'tslib';\nimport { Injectable, InjectionToken, Input, Directive, Inject, Optional, ElementRef, NgModule } from '@angular/core';\nimport { Router, PRIMARY_OUTLET, RouterPreloader, RouterLink, RouterLinkWithHref } from '@angular/router';\nimport { EMPTY } from 'rxjs';\n\n// Using a global registry so we can keep it populated across lazy-loaded\n// modules with different parent injectors which create instance of the registry.\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/router';\nconst globalRegistry = [];\nlet PrefetchRegistry = class PrefetchRegistry {\n    constructor(router) {\n        this.router = router;\n        this.trees = globalRegistry;\n    }\n    add(tree) {\n        this.trees.push(tree);\n    }\n    remove(tree) {\n        this.trees.splice(this.trees.indexOf(tree), 1);\n    }\n    shouldPrefetch(url) {\n        const tree = this.router.parseUrl(url);\n        return this.trees.some(containsTree.bind(null, tree));\n    }\n};\nPrefetchRegistry.ɵfac = function PrefetchRegistry_Factory(t) { return new (t || PrefetchRegistry)(ɵngcc0.ɵɵinject(ɵngcc1.Router)); };\nPrefetchRegistry.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PrefetchRegistry, factory: function (t) { return PrefetchRegistry.ɵfac(t); } });\nPrefetchRegistry = __decorate([ __metadata(\"design:paramtypes\", [Router])\n], PrefetchRegistry);\nfunction containsQueryParams(container, containee) {\n    // TODO: This does not handle array params correctly.\n    return (Object.keys(containee).length <= Object.keys(container).length &&\n        Object.keys(containee).every(key => containee[key] === container[key]));\n}\nfunction containsTree(containee, container) {\n    return (containsQueryParams(container.queryParams, containee.queryParams) &&\n        containsSegmentGroup(container.root, containee.root, containee.root.segments));\n}\nfunction containsSegmentGroup(container, containee, containeePaths) {\n    if (container.segments.length > containeePaths.length) {\n        const current = container.segments.slice(0, containeePaths.length);\n        if (!equalPath(current, containeePaths))\n            return false;\n        if (containee.hasChildren())\n            return false;\n        return true;\n    }\n    else if (container.segments.length === containeePaths.length) {\n        if (!equalPath(container.segments, containeePaths))\n            return false;\n        if (!containee.hasChildren())\n            return true;\n        for (const c in containee.children) {\n            if (!container.children[c])\n                break;\n            if (containsSegmentGroup(container.children[c], containee.children[c], containee.children[c].segments))\n                return true;\n        }\n        return false;\n    }\n    else {\n        const current = containeePaths.slice(0, container.segments.length);\n        const next = containeePaths.slice(container.segments.length);\n        if (!equalPath(container.segments, current))\n            return false;\n        if (!container.children[PRIMARY_OUTLET])\n            return false;\n        return containsSegmentGroup(container.children[PRIMARY_OUTLET], containee, next);\n    }\n}\nfunction equalPath(as, bs) {\n    if (as.length !== bs.length)\n        return false;\n    return as.every((a, i) => a.path === bs[i].path || a.path.startsWith(':') || bs[i].path.startsWith(':'));\n}\n\nconst ɵ0 = function (cb) {\n    const start = Date.now();\n    return setTimeout(function () {\n        cb({\n            didTimeout: false,\n            timeRemaining: function () {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n}, ɵ1 = () => { };\nconst requestIdleCallback = typeof window !== 'undefined'\n    ? window.requestIdleCallback || ɵ0\n    : ɵ1;\nconst observerSupported = () => typeof window !== 'undefined' ? !!window.IntersectionObserver : false;\nconst LinkHandler = new InjectionToken('LinkHandler');\nlet ObservableLinkHandler = class ObservableLinkHandler {\n    constructor(loader, queue) {\n        this.loader = loader;\n        this.queue = queue;\n        this.elementLink = new Map();\n        this.observer = observerSupported()\n            ? new IntersectionObserver(entries => {\n                entries.forEach(entry => {\n                    if (entry.isIntersecting) {\n                        const link = entry.target;\n                        const routerLink = this.elementLink.get(link);\n                        this.queue.add(routerLink.urlTree);\n                        this.observer.unobserve(link);\n                        requestIdleCallback(() => {\n                            this.loader.preload().subscribe(() => void 0);\n                            this.queue.remove(routerLink.urlTree);\n                        });\n                    }\n                });\n            })\n            : null;\n    }\n    register(el) {\n        this.elementLink.set(el.element, el);\n        this.observer.observe(el.element);\n    }\n    // First call to unregister will not hit this.\n    unregister(el) {\n        if (this.elementLink.has(el.element)) {\n            this.observer.unobserve(el.element);\n            this.elementLink.delete(el.element);\n        }\n    }\n    supported() {\n        return observerSupported();\n    }\n};\nObservableLinkHandler.ɵfac = function ObservableLinkHandler_Factory(t) { return new (t || ObservableLinkHandler)(ɵngcc0.ɵɵinject(ɵngcc1.RouterPreloader), ɵngcc0.ɵɵinject(PrefetchRegistry)); };\nObservableLinkHandler.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ObservableLinkHandler, factory: function (t) { return ObservableLinkHandler.ɵfac(t); } });\nObservableLinkHandler = __decorate([ __metadata(\"design:paramtypes\", [RouterPreloader, PrefetchRegistry])\n], ObservableLinkHandler);\nlet PreloadLinkHandler = class PreloadLinkHandler {\n    constructor(loader, queue) {\n        this.loader = loader;\n        this.queue = queue;\n    }\n    register(el) {\n        this.queue.add(el.urlTree);\n        requestIdleCallback(() => this.loader.preload().subscribe(() => void 0));\n    }\n    unregister(_) { }\n    supported() {\n        return true;\n    }\n};\nPreloadLinkHandler.ɵfac = function PreloadLinkHandler_Factory(t) { return new (t || PreloadLinkHandler)(ɵngcc0.ɵɵinject(ɵngcc1.RouterPreloader), ɵngcc0.ɵɵinject(PrefetchRegistry)); };\nPreloadLinkHandler.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PreloadLinkHandler, factory: function (t) { return PreloadLinkHandler.ɵfac(t); } });\nPreloadLinkHandler = __decorate([ __metadata(\"design:paramtypes\", [RouterPreloader, PrefetchRegistry])\n], PreloadLinkHandler);\n\nlet LinkDirective = class LinkDirective {\n    constructor(linkHandlers, el, link, linkWithHref) {\n        this.linkHandlers = linkHandlers;\n        this.el = el;\n        this.linkHandler = this.linkHandlers.filter(h => h.supported()).shift();\n        this.rl = link || linkWithHref;\n    }\n    ngOnChanges(c) {\n        if (c.routerLink) {\n            this.linkHandler.unregister(this);\n            this.linkHandler.register(this);\n        }\n    }\n    ngOnDestroy() {\n        this.linkHandler.unregister(this);\n    }\n    get element() {\n        return this.el.nativeElement;\n    }\n    get urlTree() {\n        return this.rl.urlTree;\n    }\n};\nLinkDirective.ɵfac = function LinkDirective_Factory(t) { return new (t || LinkDirective)(ɵngcc0.ɵɵdirectiveInject(LinkHandler), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.RouterLink, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.RouterLinkWithHref, 8)); };\nLinkDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LinkDirective, selectors: [[\"\", \"routerLink\", \"\"]], inputs: { routerLink: \"routerLink\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], LinkDirective.prototype, \"routerLink\", void 0);\nLinkDirective = __decorate([ __param(0, Inject(LinkHandler)),\n    __param(2, Optional()),\n    __param(3, Optional()),\n    __metadata(\"design:paramtypes\", [Array, ElementRef,\n        RouterLink,\n        RouterLinkWithHref])\n], LinkDirective);\n\nlet QuicklinkStrategy = class QuicklinkStrategy {\n    constructor(queue, router) {\n        this.queue = queue;\n        this.router = router;\n        this.loading = new Set();\n    }\n    preload(route, load) {\n        if (this.loading.has(route)) {\n            // Don't preload the same route twice\n            return EMPTY;\n        }\n        const conn = typeof window !== 'undefined' ? navigator.connection : undefined;\n        if (conn) {\n            // Don't preload if the user is on 2G. or if Save-Data is enabled..\n            if ((conn.effectiveType || '').includes('2g') || conn.saveData)\n                return EMPTY;\n        }\n        // Prevent from preloading\n        if (route.data && route.data.preload === false) {\n            return EMPTY;\n        }\n        const fullPath = findPath(this.router.config, route);\n        if (this.queue.shouldPrefetch(fullPath)) {\n            this.loading.add(route);\n            return load();\n        }\n        return EMPTY;\n    }\n};\nQuicklinkStrategy.ɵfac = function QuicklinkStrategy_Factory(t) { return new (t || QuicklinkStrategy)(ɵngcc0.ɵɵinject(PrefetchRegistry), ɵngcc0.ɵɵinject(ɵngcc1.Router)); };\nQuicklinkStrategy.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: QuicklinkStrategy, factory: function (t) { return QuicklinkStrategy.ɵfac(t); } });\nQuicklinkStrategy = __decorate([ __metadata(\"design:paramtypes\", [PrefetchRegistry, Router])\n], QuicklinkStrategy);\nconst findPath = (config, route) => {\n    config = config.slice();\n    const parent = new Map();\n    const visited = new Set();\n    while (config.length) {\n        const el = config.shift();\n        visited.add(el);\n        if (el === route)\n            break;\n        let children = el.children || [];\n        const current = el._loadedConfig;\n        if (current && current.routes) {\n            children = children.concat(current.routes);\n        }\n        children.forEach((r) => {\n            if (visited.has(r))\n                return;\n            parent.set(r, el);\n            config.push(r);\n        });\n    }\n    let path = '';\n    let current = route;\n    while (current) {\n        if (isPrimaryRoute(current)) {\n            path = `/${current.path}${path}`;\n        }\n        else {\n            path = `/(${current.outlet}:${current.path}${path})`;\n        }\n        current = parent.get(current);\n    }\n    return path;\n};\nfunction isPrimaryRoute(route) {\n    return route.outlet === PRIMARY_OUTLET || !route.outlet;\n}\n\nlet QuicklinkModule = class QuicklinkModule {\n};\nQuicklinkModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: QuicklinkModule });\nQuicklinkModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function QuicklinkModule_Factory(t) { return new (t || QuicklinkModule)(); }, providers: [\n        {\n            provide: LinkHandler,\n            useClass: ObservableLinkHandler,\n            multi: true\n        },\n        {\n            provide: LinkHandler,\n            useClass: PreloadLinkHandler,\n            multi: true\n        },\n        PrefetchRegistry,\n        QuicklinkStrategy\n    ] });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PrefetchRegistry, [{\n        type: Injectable\n    }], function () { return [{ type: ɵngcc1.Router }]; }, null); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ObservableLinkHandler, [{\n        type: Injectable\n    }], function () { return [{ type: ɵngcc1.RouterPreloader }, { type: PrefetchRegistry }]; }, null); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PreloadLinkHandler, [{\n        type: Injectable\n    }], function () { return [{ type: ɵngcc1.RouterPreloader }, { type: PrefetchRegistry }]; }, null); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LinkDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[routerLink]'\n            }]\n    }], function () { return [{ type: Array, decorators: [{\n                type: Inject,\n                args: [LinkHandler]\n            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.RouterLink, decorators: [{\n                type: Optional\n            }] }, { type: ɵngcc1.RouterLinkWithHref, decorators: [{\n                type: Optional\n            }] }]; }, { routerLink: [{\n            type: Input\n        }] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(QuicklinkStrategy, [{\n        type: Injectable\n    }], function () { return [{ type: PrefetchRegistry }, { type: ɵngcc1.Router }]; }, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(QuicklinkModule, { declarations: [LinkDirective], exports: [LinkDirective] }); })();\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(QuicklinkModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [LinkDirective],\n                providers: [\n                    {\n                        provide: LinkHandler,\n                        useClass: ObservableLinkHandler,\n                        multi: true\n                    },\n                    {\n                        provide: LinkHandler,\n                        useClass: PreloadLinkHandler,\n                        multi: true\n                    },\n                    PrefetchRegistry,\n                    QuicklinkStrategy\n                ],\n                exports: [LinkDirective]\n            }]\n    }], null, null); })();\n\nexport { QuicklinkModule, QuicklinkStrategy, LinkHandler as ɵa, ObservableLinkHandler as ɵb, PreloadLinkHandler as ɵc, PrefetchRegistry as ɵe, LinkDirective as ɵɵLinkDirective };\n\n//# sourceMappingURL=ngx-quicklink.js.map","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { QuicklinkModule } from 'ngx-quicklink';\n\n\n@NgModule({\n  declarations: [],\n  imports: [\n    CommonModule,\n    QuicklinkModule\n  ],\n  exports: [\n    QuicklinkModule\n  ]\n})\nexport class SharedModule { }\n"],"sourceRoot":"webpack:///"}